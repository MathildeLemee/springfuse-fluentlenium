/*
 * (c) Copyright 2005-2011 JAXIO, www.jaxio.com
 * Source code generated by Celerio, a Jaxio product
 * Want to use Celerio within your company? email us at info@jaxio.com
 * Follow us on twitter: @springfuse
 * Template pack-backend:src/main/java/project/domain/Entity.e.vm.java
 */
package com.yourcompany.yourproject.domain;

import static javax.persistence.CascadeType.ALL;
import static javax.persistence.CascadeType.PERSIST;
import static javax.persistence.FetchType.LAZY;
import static org.hibernate.annotations.CacheConcurrencyStrategy.NONSTRICT_READ_WRITE;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.QueryHint;
import javax.persistence.Table;
import javax.persistence.Transient;
import javax.persistence.Version;
import javax.xml.bind.annotation.XmlTransient;
import org.apache.log4j.Logger;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.Filter;
import org.hibernate.annotations.FilterDef;
import org.hibernate.annotations.GenericGenerator;
import org.hibernate.annotations.ParamDef;
import org.hibernate.validator.constraints.Email;
import org.hibernate.validator.constraints.Length;
import org.hibernate.validator.constraints.NotEmpty;
import com.yourcompany.yourproject.domain.Address;
import com.yourcompany.yourproject.domain.Book;
import com.yourcompany.yourproject.domain.ContactInfo;
import com.yourcompany.yourproject.domain.Document;
import com.yourcompany.yourproject.domain.Role;

@Entity
@Table(name = "ACCOUNT")
@NamedQuery(name = "Account.selectAll", query = "from com.yourcompany.yourproject.domain.Account as account where 1 = 1", hints = {
        @QueryHint(name = "org.hibernate.comment", value = "enableDynamicOrderBySupport"),
        @QueryHint(name = "org.hibernate.cacheable", value = "true") })
@Cache(usage = NONSTRICT_READ_WRITE)
@FilterDef(name = "myAccountFilter", defaultCondition = "ACCOUNT_ID = :currentAccountId ", parameters = @ParamDef(name = "currentAccountId", type = "org.hibernate.type.StringType"))
@Filter(name = "myAccountFilter")
public class Account implements Identifiable<String>, Serializable {
    private static final long serialVersionUID = 1L;
    private static final Logger logger = Logger.getLogger(Account.class);

    // Raw attributes
    private String accountId; // pk
    private String username; // unique (not null)
    private String password; // not null
    private String email; // unique (not null)
    private Boolean isEnabled;
    private Integer version;

    // Technical attributes for query by example
    private Integer addressId;

    // Many to one
    private Address homeAddress; // (addressId)

    // One to one
    private ContactInfo contactInformation; // inverse side

    // One to many
    private List<Book> books = new ArrayList<Book>();
    private List<Document> documents = new ArrayList<Document>();

    // Many to many
    private List<Role> roles = new ArrayList<Role>();

    // ---------------------------
    // Constructors
    // ---------------------------

    public Account() {
    }

    public Account(String primaryKey) {
        setPrimaryKey(primaryKey);
    }

    // ---------------------------
    // Identifiable implementation
    // ---------------------------

    @Transient
    @XmlTransient
    public String getPrimaryKey() {
        return getAccountId();
    }

    public void setPrimaryKey(String accountId) {
        setAccountId(accountId);
    }

    @Transient
    @XmlTransient
    public boolean isPrimaryKeySet() {
        return isAccountIdSet();
    }

    // -------------------------------
    // Role names support
    // -------------------------------

    /**
     * Returns the granted authorities for this user. You may override
     * this method to provide your own custom authorities.
     */
    @Transient
    @XmlTransient
    public List<String> getRoleNames() {
        List<String> roleNames = new ArrayList<String>();

        for (Role role : getRoles()) {
            roleNames.add(role.getRoleName());
        }

        return roleNames;
    }

    // -------------------------------
    // Getter & Setter
    // -------------------------------

    // -- [accountId] ------------------------

    @Column(name = "ACCOUNT_ID", nullable = false, unique = true, length = 32)
    @GeneratedValue(generator = "strategy-uuid")
    @GenericGenerator(name = "strategy-uuid", strategy = "uuid")
    @Id
    public String getAccountId() {
        return accountId;
    }

    public void setAccountId(String accountId) {
        this.accountId = accountId;
    }

    @Transient
    public boolean isAccountIdSet() {
        return accountId != null && !accountId.isEmpty();
    }

    // -- [username] ------------------------

    @NotEmpty
    @Length(min = 4, max = 255)
    @Column(name = "login", nullable = false, unique = true)
    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    // -- [password] ------------------------

    @NotEmpty
    @Length(max = 255)
    @Column(name = "`PASSWORD`", nullable = false)
    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    // -- [email] ------------------------

    @NotEmpty
    @Length(max = 255)
    @Email
    @Column(nullable = false, unique = true)
    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    // -- [isEnabled] ------------------------

    @Column(name = "is_enabled", length = 1)
    public Boolean getIsEnabled() {
        return isEnabled;
    }

    public void setIsEnabled(Boolean isEnabled) {
        this.isEnabled = isEnabled;
    }

    // -- [addressId] ------------------------

    @Column(name = "address_id", precision = 10, insertable = false, updatable = false)
    public Integer getAddressId() {
        return addressId;
    }

    private void setAddressId(Integer addressId) {
        this.addressId = addressId;
    }

    // -- [version] ------------------------

    @Column(name = "VERSION", precision = 10)
    @Version
    public Integer getVersion() {
        return version;
    }

    public void setVersion(Integer version) {
        this.version = version;
    }

    // --------------------------------------------------------------------
    // Many to One support
    // --------------------------------------------------------------------

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // many-to-one: Account.addressId ==> Address.addressId
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    @Cache(usage = NONSTRICT_READ_WRITE)
    @JoinColumn(name = "address_id")
    @ManyToOne(cascade = PERSIST, fetch = LAZY)
    public Address getHomeAddress() {
        return homeAddress;
    }

    /**
     * Set the homeAddress without adding this Account instance on the passed homeAddress
     * If you want to preserve referential integrity we recommend to use
     * instead the corresponding adder method provided by Address
     */
    public void setHomeAddress(Address homeAddress) {
        this.homeAddress = homeAddress;

        // We set the foreign key property so it can be used by Hibernate search by Example facility.
        if (homeAddress != null) {
            setAddressId(homeAddress.getAddressId());
        } else {
            setAddressId(null);
        }
    }

    // --------------------------------------------------------------------
    // One to one
    // --------------------------------------------------------------------

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // Inverse side of one-to-one relation: Account.accountId ==> ContactInfo.accountId
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    @Cache(usage = NONSTRICT_READ_WRITE)
    @OneToOne(cascade = ALL, fetch = LAZY, orphanRemoval = true, mappedBy = "parent")
    public ContactInfo getContactInformation() {
        return contactInformation;
    }

    public void setContactInformation(ContactInfo contactInformation) {
        this.contactInformation = contactInformation;

        if (this.contactInformation != null) {
            this.contactInformation.setParent((Account) this);
        }
    }

    // --------------------------------------------------------------------
    // One to Many support: account ==> books
    // --------------------------------------------------------------------

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // one to many: account ==> books
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    @Cache(usage = NONSTRICT_READ_WRITE)
    @OneToMany(mappedBy = "account", orphanRemoval = true, cascade = ALL)
    public List<Book> getBooks() {
        return books;
    }

    /**
     * Set the Book List.
     * It is recommended to use the helper method addBook / removeBook
     * if you want to preserve referential integrity at the object level.
     *
     * @param books the list to set
     */
    public void setBooks(List<Book> books) {
        this.books = books;
    }

    /**
     * Helper method to add the passed book to the books List
     * and set this account on the passed book to preserve referential
     * integrity at the object level.
     *
     * @param book the to add
     * @return true if the book could be added to the books List, false otherwise
     */
    public boolean addBook(Book book) {
        boolean addedOK = getBooks().add(book);

        if (addedOK) {
            book.setAccount((Account) this);
        } else {
            logger.warn("add returned false");
        }

        return addedOK;
    }

    /**
     * Helper method to determine if the passed book is already present in the books List.
     *
     * @param book the instance to look up.
     * @return true if the books List contains the passed book, false otherwise.
     */
    public boolean containsBook(Book book) {
        return getBooks() != null && getBooks().contains(book);
    }

    /**
     * Helper method to remove the passed book from the books List and unset
     * this account from the passed book to preserve referential integrity at the object level.
     *
     * @param book the instance to remove
     * @return true if the book could be removed from the books List, false otherwise
     */
    public boolean removeBook(Book book) {
        boolean removedOK = getBooks().remove(book);

        if (removedOK) {
            book.setAccount(null);
        } else {
            logger.warn("remove returned false");
        }

        return removedOK;
    }

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // one to many: account ==> documents
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    @Cache(usage = NONSTRICT_READ_WRITE)
    @OneToMany(mappedBy = "account", orphanRemoval = true, cascade = ALL)
    public List<Document> getDocuments() {
        return documents;
    }

    /**
     * Set the Document List.
     * It is recommended to use the helper method addDocument / removeDocument
     * if you want to preserve referential integrity at the object level.
     *
     * @param documents the list to set
     */
    public void setDocuments(List<Document> documents) {
        this.documents = documents;
    }

    /**
     * Helper method to add the passed document to the documents List
     * and set this account on the passed document to preserve referential
     * integrity at the object level.
     *
     * @param document the to add
     * @return true if the document could be added to the documents List, false otherwise
     */
    public boolean addDocument(Document document) {
        boolean addedOK = getDocuments().add(document);

        if (addedOK) {
            document.setAccount((Account) this);
        } else {
            logger.warn("add returned false");
        }

        return addedOK;
    }

    /**
     * Helper method to determine if the passed document is already present in the documents List.
     *
     * @param document the instance to look up.
     * @return true if the documents List contains the passed document, false otherwise.
     */
    public boolean containsDocument(Document document) {
        return getDocuments() != null && getDocuments().contains(document);
    }

    /**
     * Helper method to remove the passed document from the documents List and unset
     * this account from the passed document to preserve referential integrity at the object level.
     *
     * @param document the instance to remove
     * @return true if the document could be removed from the documents List, false otherwise
     */
    public boolean removeDocument(Document document) {
        boolean removedOK = getDocuments().remove(document);

        if (removedOK) {
            document.setAccount(null);
        } else {
            logger.warn("remove returned false");
        }

        return removedOK;
    }

    // --------------------------------------------------------------------
    // Many to Many
    // --------------------------------------------------------------------

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    // many-to-many: accounts ==> roles
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    /**
     * Returns the roles List.
     */
    @Cache(usage = NONSTRICT_READ_WRITE)
    @JoinTable(name = "ACCOUNT_ROLE", joinColumns = @JoinColumn(name = "ACCOUNT_ID"), inverseJoinColumns = @JoinColumn(name = "role_id"))
    @ManyToMany(cascade = PERSIST)
    public List<Role> getRoles() {
        return roles;
    }

    /**
     * Set the roles List.
     * It is recommended to use the helper method addRole /  removeRole
     * if you want to preserve referential integrity at the object level.
     *
     * @param roles the List of Role
     */
    public void setRoles(List<Role> roles) {
        this.roles = roles;
    }

    /**
     * Helper method to add the passed role to the roles List.
     */
    public boolean addRole(Role role) {
        return getRoles().add(role);
    }

    /**
     * Helper method to remove the passed role from the roles List.
     */
    public boolean removeRole(Role role) {
        return getRoles().remove(role);
    }

    /**
     * Helper method to determine if the passed role is present in the roles List.
     */
    public boolean containsRole(Role role) {
        return getRoles() != null && getRoles().contains(role);
    }

    // -----------------------------------------
    // Set defaults values
    // -----------------------------------------

    /**
     * Set the default values.
     */
    public void initDefaultValues() {
    }

    // -----------------------------------------
    // equals and hashCode
    // -----------------------------------------

    /**
     * equals implementation using a business key.
     */
    @Override
    public boolean equals(Object account) {
        if (this == account) {
            return true;
        }

        if (!(account instanceof Account)) {
            return false;
        }

        Account other = (Account) account;

        if (getUsername() == null) {
            if (other.getUsername() != null) {
                return false;
            }
        } else if (!getUsername().equals(other.getUsername())) {
            return false;
        }

        return true;
    }

    private volatile int previousHashCode = 0;

    /**
     * hashCode implementation using a business key.
     */
    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + (getUsername() != null ? getUsername().hashCode() : 0);

        if (previousHashCode != 0 && previousHashCode != result) {
            logger.warn("DEVELOPER: hashCode has changed!."
                    + "If you encounter this message you should take the time to carefuly review equals/hashCode for: "
                    + getClass().getCanonicalName());
        }

        previousHashCode = result;
        return result;
    }

    // -----------------------------------------
    // toString
    // -----------------------------------------

    /**
     * Construct a readable string representation for this Account instance.
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder result = new StringBuilder();
        result.append("account.accountId=[").append(getAccountId()).append("]\n");
        result.append("account.username=[").append(getUsername()).append("]\n");
        result.append("account.password=[").append(getPassword()).append("]\n");
        result.append("account.email=[").append(getEmail()).append("]\n");
        result.append("account.isEnabled=[").append(getIsEnabled()).append("]\n");
        result.append("account.addressId=[").append(getAddressId()).append("]\n");
        result.append("account.version=[").append(getVersion()).append("]\n");
        return result.toString();
    }
}